{"ast":null,"code":"import axios from \"axios\";\nconst api = axios.create({\n  baseURL: process.env.REACT_APP_API_URL || \"http://localhost:5000/api\"\n});\n\n// Add token to all requests if exists\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem(\"token\");\n  if (token) config.headers.Authorization = `Bearer ${token}`;\n  return config;\n}, error => Promise.reject(error));\n\n// Response interceptor: if 401, try to refresh access token using refresh token\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) prom.reject(error);else prom.resolve(token);\n  });\n  failedQueue = [];\n};\napi.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    const refreshToken = localStorage.getItem(\"refreshToken\");\n    if (!refreshToken) {\n      // No refresh token - clear storage and reject\n      localStorage.removeItem(\"token\");\n      localStorage.removeItem(\"refreshToken\");\n      localStorage.removeItem(\"user\");\n      return Promise.reject(error);\n    }\n    if (isRefreshing) {\n      // Queue requests while refreshing\n      return new Promise(function (resolve, reject) {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers.Authorization = 'Bearer ' + token;\n        return api(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    isRefreshing = true;\n    try {\n      const res = await api.post('/auth/refresh', {\n        refreshToken\n      });\n      const newToken = res.data.token || res.data.accessToken || res.data;\n      // store new token\n      if (newToken) {\n        localStorage.setItem('token', newToken);\n        api.defaults.headers.common['Authorization'] = 'Bearer ' + newToken;\n      }\n      // if a rotated refresh token is returned, update it\n      if (res.data.refreshToken) {\n        localStorage.setItem('refreshToken', res.data.refreshToken);\n      }\n      processQueue(null, newToken);\n      isRefreshing = false;\n      originalRequest.headers.Authorization = 'Bearer ' + newToken;\n      return api(originalRequest);\n    } catch (err) {\n      processQueue(err, null);\n      isRefreshing = false;\n      // Clear storage on failed refresh\n      localStorage.removeItem('token');\n      localStorage.removeItem('refreshToken');\n      localStorage.removeItem('user');\n      return Promise.reject(err);\n    }\n  }\n  return Promise.reject(error);\n});\nexport default api;","map":{"version":3,"names":["axios","api","create","baseURL","process","env","REACT_APP_API_URL","interceptors","request","use","config","token","localStorage","getItem","headers","Authorization","error","Promise","reject","isRefreshing","failedQueue","processQueue","forEach","prom","resolve","response","originalRequest","status","_retry","refreshToken","removeItem","push","then","catch","err","res","post","newToken","data","accessToken","setItem","defaults","common"],"sources":["C:/PMMM Buá»•i 4/group14-project/group14-project/group14-project/frontend/src/services/api.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\nconst api = axios.create({\r\n  baseURL: process.env.REACT_APP_API_URL || \"http://localhost:5000/api\",\r\n});\r\n\r\n// Add token to all requests if exists\r\napi.interceptors.request.use((config) => {\r\n  const token = localStorage.getItem(\"token\");\r\n  if (token) config.headers.Authorization = `Bearer ${token}`;\r\n  return config;\r\n}, (error) => Promise.reject(error));\r\n\r\n// Response interceptor: if 401, try to refresh access token using refresh token\r\nlet isRefreshing = false;\r\nlet failedQueue = [];\r\n\r\nconst processQueue = (error, token = null) => {\r\n  failedQueue.forEach(prom => {\r\n    if (error) prom.reject(error);\r\n    else prom.resolve(token);\r\n  });\r\n  failedQueue = [];\r\n};\r\n\r\napi.interceptors.response.use(\r\n  response => response,\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n\r\n    if (error.response && error.response.status === 401 && !originalRequest._retry) {\r\n      originalRequest._retry = true;\r\n\r\n      const refreshToken = localStorage.getItem(\"refreshToken\");\r\n      if (!refreshToken) {\r\n        // No refresh token - clear storage and reject\r\n        localStorage.removeItem(\"token\");\r\n        localStorage.removeItem(\"refreshToken\");\r\n        localStorage.removeItem(\"user\");\r\n        return Promise.reject(error);\r\n      }\r\n\r\n      if (isRefreshing) {\r\n        // Queue requests while refreshing\r\n        return new Promise(function(resolve, reject) {\r\n          failedQueue.push({ resolve, reject });\r\n        }).then(token => {\r\n          originalRequest.headers.Authorization = 'Bearer ' + token;\r\n          return api(originalRequest);\r\n        }).catch(err => Promise.reject(err));\r\n      }\r\n\r\n      isRefreshing = true;\r\n\r\n      try {\r\n        const res = await api.post('/auth/refresh', { refreshToken });\r\n        const newToken = res.data.token || res.data.accessToken || res.data;\r\n        // store new token\r\n        if (newToken) {\r\n          localStorage.setItem('token', newToken);\r\n          api.defaults.headers.common['Authorization'] = 'Bearer ' + newToken;\r\n        }\r\n        // if a rotated refresh token is returned, update it\r\n        if (res.data.refreshToken) {\r\n          localStorage.setItem('refreshToken', res.data.refreshToken);\r\n        }\r\n\r\n        processQueue(null, newToken);\r\n        isRefreshing = false;\r\n\r\n        originalRequest.headers.Authorization = 'Bearer ' + newToken;\r\n        return api(originalRequest);\r\n      } catch (err) {\r\n        processQueue(err, null);\r\n        isRefreshing = false;\r\n        // Clear storage on failed refresh\r\n        localStorage.removeItem('token');\r\n        localStorage.removeItem('refreshToken');\r\n        localStorage.removeItem('user');\r\n        return Promise.reject(err);\r\n      }\r\n    }\r\n\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default api;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}